# Mink Backend - Developer's Guide

Mink is [Språkbanken Text](https://spraakbanken.gu.se/)'s data platform, allowing users to upload corpus data, annotate
it with [Sparv](https://spraakbanken.gu.se/sparv), and view or search it in [Korp](https://spraakbanken.gu.se/korp) and
[Strix](https://spraakbanken.gu.se/strix).

This backend is a FastAPI application that supports the [Mink frontend](https://spraakbanken.gu.se/mink). It provides
endpoints for uploading and downloading corpus files, processing corpora with Sparv, and installing them in Korp and
Strix.

This document is intended for Mink backend developers. It describes the backend's functionality, outlines the
application's structure and key components, and explains how the API is documented and tested.

## Server Setup

The Mink backend can be distributed across several servers, each serving a specific role:

- **Backend server**: Hosts the FastAPI application, handling API requests and coordinating backend operations.
- **Storage server**: Stores users' corpus source files, configuration files, and export files. This server ensures
  persistent storage and access to all corpus-related data.
- **Sparv server**: Runs Sparv for annotation and processing tasks. Ideally equipped with a GPU, this server requires
  the corpus source and config files to be synchronized from the storage server before processing. Temporary working
  files are stored here during processing and may be deleted after completion or inactivity. Export files generated by
  Sparv are also stored here and later synchronized back to the storage server. In the current Mink setup, the Sparv
  server also serves as the storage server.
- **Installation targets**: Installing corpora from Mink involves synchronizing specific Sparv export files to servers
  hosting other applications, such as Korp and Strix.

## Workflow for Mink Users

While users are not required to follow a strict sequence when interacting with the Mink backend, there is a recommended
workflow that helps ensure successful data processing. The following steps outline this typical workflow and provide an
overview of how the Mink backend operates.

### Creating a New Corpus

Before any data can be uploaded or processed, a user must create a corpus. (When using the Mink frontend, this step is
handled automatically.) Creating a new corpus generates a unique corpus ID (prefixed with `mink-`) and an [info
object](#info-object). The corpus ID is registered in the authentication system, and the user who creates the corpus is
assigned owner rights. To create a new corpus, use the `/create-corpus` route.

### Uploading Corpus Source Files

When you upload corpus source files, they are stored on the [storage server](#server-setup) in a directory named after
the corpus ID. If you upload multiple files, the backend checks that all file extensions match, as Sparv requires source
files to be of the same type. Use the `/upload-sources` route to upload your source files.

### Uploading a Corpus Config File

Before a corpus can be processed with Sparv, the user must upload a [Sparv corpus config
file](https://spraakbanken.gu.se/sparv/#/user-manual/corpus-configuration). When using Mink through the frontend, this
step is usually handled automatically, as the frontend generates a default config file. When a config file is uploaded,
the backend checks that the `importer` specified in the config matches the file extension of any previously uploaded
source files (if present). To upload a config file, use the `/upload-config` route.

### Running Sparv

When a corpus has both source files and a corpus config file, it can be processed with Sparv. This process enriches the
source files with automatic annotations and generates various output formats (exports). To start processing, use the
`/run-sparv` route. If the [storage server](#server-setup) and [Sparv server](#server-setup) are separate, calling
`/run-sparv` will first synchronize the source and config files from the storage server to the Sparv server; otherwise,
this step is skipped. Before running Sparv, the backend verifies that the `importer` specified in the config file
matches the file extension of the source files (if the config was uploaded first).

The Sparv job is then added to the [job queue](#job-queue). Once all previous jobs in the queue have been processed, the
[queue manager](#queue-manager) will automatically run this job, and Sparv will process the corpus.

### Checking the Status

When a job has been queued, its status can be checked using the `/resource-info` route. The response includes details
such as the queue priority, the status of the annotation process, processing duration, and any warnings or errors
generated by Sparv. For an explanation of the different status codes, refer to the `/status-codes` route.

In setups where the [storage server](#server-setup) and [Sparv server](#server-setup) are separate, it is necessary to
call `/resource-info` after the annotation process completes to ensure export files are synchronized.

### Downloading Export Files

After a Sparv job completes, users can download the resulting export files for further analysis or use. This is done via
the `/download-exports` route. Users may choose to download all available exports, or select specific subdirectories or
files as needed.

### Installing in Korp and/or Strix

In addition to downloading export files, users may want to install their corpus in the corpus search tools Korp or Strix
(or both). This is accomplished using the `/install-korp` and `/install-strix` routes. Installation is performed by
Sparv, and the installation job is added to the job queue in the same way as annotation jobs.

After a successful installation, users can log in to Korp or Strix and search their own corpora as usual. Installations
are private, meaning only the logged-in user who owns the installed corpus can view it.

### Other Resource Types

Currently, the Mink backend is primarily designed for processing and installing corpora. However, support for a new
resource type, "metadata," has recently been introduced. A metadata resource consists of a YAML file containing
descriptive information about a corpus, lexicon, analysis, or collection. These metadata files are used to generate
[Språkbanken Text's resources page](https://spraakbanken.gu.se/en/resources). For more details about the structure and
usage of metadata YAML files, see the [metadata repository](https://github.com/spraakbanken/metadata).

You can create a metadata resource using the `/create-metadata` route and remove it with the `/remove-metadata` route.
The metadata file itself is uploaded via the `/upload-metadata` route and can be downloaded using the
`/download-metadata` route.

Additional features for metadata resources are planned, and support for other resource types may be added in the future.

## Key Concepts

The following sections describe some important concepts and components of the Mink backend. These concepts are essential
for understanding how the backend operates and how it interacts with other parts of the application.

### Configuration

The default configuration for the Mink backend is stored in the `Settings` class in `mink/core/config.py`. This
configuration may be overridden by creating a `.env` file in the root directory of the Mink backend project. The `.env`
file should be formatted as a standard environment variable file, with each line containing a key-value pair. For
example:

```bash
LOG_LEVEL=DEBUG
LOG_TO_FILE=False
MINK_URL=http://localhost:8000
SPARV_IMPORTER_MODULES={
    ".xml":"xml_import",
    ".txt":"text_import",
    ".pdf":"pdf_import"
}
```

All configuration variables are then accessible through the `mink.core.config.settings` object:

```python
from mink.core.config import settings

print(settings.MINK_URL)  # Output: http://localhost:8000
```

### Instance Directory

The instance directory is a directory in the backend's root directory that contains all files related to the backend's
operation. This includes the following:

- `logs/`: Directory for storing log files
- `registry/`: Directory for storing the resource registry
- `tmp/`: Directory for temporary storage of files downloaded by the user
- `pubkey.pem`: Public key for verifying JWT tokens
- `queue`: File for storing the job queue

### Resource ID

A resource ID is a unique identifier for a corpus in the Mink backend. It is generated when a new corpus is created and
is prefixed with `mink-`. The resource ID is used to reference the corpus in various API calls and is essential for
tracking the corpus throughout its lifecycle. The resource ID is also registered in the authentication system, allowing
the backend to manage user permissions and access control for the corpus.

### Info Object

An info object is created when a new resource (corpus) is created. It consists of three main sub-objects:

- `resource`: Contains general properties of the corpus, such as its [resource ID](#resource-id), names in different
  languages, resource type, and the list of available source files.
- `owner`: Contains information about the user who created the resource, including user ID, name, and email address.
- `job`: Contains details about the most recent Sparv job run for the resource, such as job status, annotation progress,
  and queue priority.

The info object is stored as a JSON file in the backend's instance directory and is also cached using
[Memcached](https://memcached.org/) for faster access. The info object is updated whenever `/resource-info` is called,
if any information has changed.

### Job Queue

To prevent Sparv from being overloaded by too many simultaneous annotation or installation processes, the Mink backend
uses a job queue system. When a user requests to process or install a corpus, the backend adds a job to the queue. The
[queue manager](#queue-manager), which runs as a separate process, regularly checks whether there is available
capacity—determined by the `SPARV_WORKERS` configuration variable, which specifies how many Sparv jobs can run
concurrently. If capacity is available, the backend will start the annotation or installation process for the next job
in the queue. The queue manager communicates with the backend API by calling the `/advance-queue` route.

The job queue is a list of queued resource IDs and is stored in plain text in the instance directory of the backend and
is also cached using [Memcached](https://memcached.org/) for faster access.

### Queue Manager

The queue manager operates as an external process, separate from the FastAPI application. It is scheduled to run at
regular intervals using the [APScheduler](https://apscheduler.readthedocs.io/en/3.x/) Python package. The queue manager
interacts with the Mink backend by calling the `/advance-queue` API route, which performs the following actions:

1. Removes jobs from the queue that have completed, been aborted, or encountered errors.
2. Checks running jobs to ensure their processes are still active; if not, those jobs are removed.
3. If the number of running jobs is below the configured limit (defined by the `SPARV_WORKERS` variable), starts the
   next job in the queue.

### Resource Registry

The resource registry maintains a record of all resources managed by Mink, along with their positions in the job queue
(if applicable). It functions as a dictionary that maps each resource ID to its associated info object.

When the application starts, all info objects are loaded from their respective JSON files and cached for efficient
access. The job queue is also read from the instance directory and cached. This setup enables the backend to manage
resources and queue positions quickly and reliably.

A resource remains in the registry from the moment it is created until it is deleted.

## Project Structure

The Mink backend is designed to be modular and extensible, allowing for easy integration with other components and
services. A Mink developer should aim to keep the code modular and reusable, enabling the possibility of replacing
individual components with alternative implementations in the future.

The `main.py` file serves as the entry point for the FastAPI application. It initializes the app, configures middleware,
registers API routes, and adjusts the OpenAPI specification as needed. The application is organized into several
packages to promote modularity and maintainability.

The `core` package provides essential functionality that is tightly integrated with the Mink backend and is not intended
to be replaced. It includes the following modules:

- `config.py`: Default Mink backend settings.
- `exceptions.py`: Mink-specific exceptions.
- `info.py`: Creation and management of resource info objects.
- `jobs.py`: Management and execution of corpus jobs (processing and installation).
- `logging.py`: Logging setup and configuration.
- `models.py`: Pydantic models for API requests and responses.
- `registry.py`: Resource registry and job queue management.
- `resource.py`: Classes for resource object creation and handling.
- `routes.py`: General routes independent of non-core functionality (e.g., documentation serving).
- `status.py`: Classes for job status handling.
- `user.py`: User property management.
- `utils.py`: General utility functions.

Non-core packages provide additional, more easily replaceable functionality:

- `cache`: Caching with [Memcached](https://memcached.org/).
- `metadata`: Handling metadata files (a new resource type in Mink).
- `sb_auth`: Authentication with sbAuth.
- `sparv`: Processing jobs with Sparv and file storage.

## API Documentation

The API for this application is documented using the [OpenAPI Specification](https://spec.openapis.org/oas/v3.1.0)
(OAS), a standard for describing HTTP APIs. The OAS is used to generate the documentation web page available at the
`/openapi.json` route.

Starting from version 1.3.0, the OAS is generated automatically by FastAPI. To ensure the documentation remains
accurate, keep the docstrings of the route functions up to date. These docstrings typically include bash examples
demonstrating how to call the routes with CURL. Pydantic models are used to define the structure of request and response
data.

## Testing

Currently, there are no automated tests for the Mink backend. Manual testing can be performed using SwaggerUI, which is
included with FastAPI. To access it, navigate to <http://localhost:8000/docs> in your browser. SwaggerUI displays all
documented routes and provides "Try it out" buttons for sending requests directly to the backend.

For local development, set `ENV=development` in your `.env` configuration file. This ensures SwaggerUI targets your
local backend URL. If you add your sb-auth API key to `SBAUTH_PERSONAL_API_KEY`, you will be automatically authenticated
for each request. You can also set `DEFAULT_RESOURCE_ID` to one of your Mink resource IDs to pre-fill the `resource-id`
parameter in relevant routes.

Alternatively, you can download the OpenAPI Specification (OAS) from the `/api-spec` route and import it into tools like
[Apidog](https://apidog.com/) or [Postman](https://www.postman.com/). When using these tools, you may need to configure
environment variables such as `host` (e.g., `http://localhost:8000`) and set up authentication (either JWT or API key).
